# Спецификации и сценарии тестов

* [1. Спецификации на входы](#1-спецификации-на-входы)
* [2. Спецификации на выходы](#2-спецификации-на-выходы)
* [3. Среда тестирования](#3-среда-тестирования)
* [4. Специальные требования](#4-специальные-требования)
* [5. Взаимозависимости](#5-взаимозависимости)
* [6. Тесты](#6-тесты)
    * [6.1. Компонентные тесты](#61-компонентные-тесты)
    * [6.2. Unit-тесты](#62-unit-тесты)

## 1. Спецификации на входы

**К входам относятся:**

* Ввод данных пользователем через интерфейс приложения (формы, команды, кнопки).
* Структурированные данные в формате JSON, поступающие от сервера.
* Файлы конфигурации приложения.
* Авторизационные данные (логин/UserName-Telegram).
* Действия пользователя: запуск приложения, создание задачи, назначение исполнителя.
* Сетевая среда — наличие интернет-соединения.

**Характеристики входов:**

* Формат данных: JSON, текстовые строки UTF-8.
* Диапазоны значений: длина текстовых полей до 512 символов.
* Протоколы: HTTPS для обмена с сервером.
* Требуемые предварительные состояния: наличие зарегистрированного пользователя.

## 2. Спецификации на выходы

Выходы определяют результаты, которые тестируемая система должна сгенерировать:

* Ответы API в формате JSON.
* Изменённые состояния приложения (созданная задача, обновлённая история).
* Сообщения интерфейса: уведомления, ошибки ввода, подтверждения.
* Логи действий пользователя.
* Метрики выполнения (время реакции, корректность результата).

**Каждый тест должен явно приводить:**

* полученный объект данных,
* отображаемый текст,
* ожидаемый статус операции.

## 3. Среда тестирования

* **Операционная система:** Windows 10, 11 / macOS Sequoia
* **Оборудование:** ПК с 8+ ГБ RAM, процессор не ниже Intel i5 / M1.
* **ПО:**
    * Node.js v18+ (при тестировании фронтенда),
    * Docker (опционально),
    * браузер Chrome 125+,
    * система управления версиями Git.
* **Инструменты тестирования:**
    * Jest / Go testing — модульные тесты,
    * Postman — тестирование API,
    * Cypress — e2e-тесты,
    * системные логи.

## 4. Специальные требования

* Тестирование проводится на чистой базе данных (reset).
* Должна быть обеспечена стабильная сеть не ниже 5 Мбит/с.
* Все тесты выполняются под тестовым пользователем.
* Время реакции сервера — не более 1 секунды для стандартных запросов.
* Недопустимо ручное вмешательство в систему во время выполнения тестов.

## 5. Взаимозависимости

* Тест 1 должен выполняться первым, так как формирует первоначальное состояние.
* Тест 2 зависит от корректного выполнения Теста 1.
* Свойство A внутри каждого теста должно быть проверено до проверки Свойства B.
* Все тесты должны выполняться на одной и той же версии сборки.

## 6. Тесты

### 6.1. Компонентные тесты

#### Тест 1. Обновление статуса от неизвестного пользователя

**Что тестирует:** Проверяется, что функция обновления статуса задачи возвращает ошибку, если пользователь не найден.  
**Вход:** `userId='unknown'`, `taskId='1'`, `newStatus='assigned'`  
**Выход:** ошибка (пользователь не найден)

#### Тест 2. Обновление статуса обычным пользователем

**Что тестирует:** Функция обновления статуса должна запрещать изменение статуса, если пользователь не менеджер.  
**Вход:** `userId='user1'` (роль: user), `taskId='1'`, `newStatus='completed'`  
**Выход:** ошибка (нет прав на изменение статуса)

#### Тест 3. Обновление статуса менеджером

**Что тестирует:** Функция обновления статуса должна успешно обновлять статус при выполнении запроса менеджером.  
**Вход:** `userId='manager1'` (роль: manager), `taskId='1'`, `newStatus='completed'`  
**Выход:** успешное обновление статуса (`true` или обновлённая задача)

#### Тест 4. Получение несуществующего пользователя

**Что тестирует:** Функция получения пользователя должна возвращать ошибку, если пользователь отсутствует.  
**Вход:** `userId='unknown'`  
**Выход:** ошибка (пользователь не найден)

#### Тест 5. Получение существующего пользователя

**Что тестирует:** Проверка корректной выдачи информации о существующем пользователе.  
**Вход:** `userId='user1'`  
**Выход:** объект пользователя `{ id: 'user1', ... }`

#### Тест 6. SQL запрос на создание пользователя

**Что тестирует:** Корректность SQL-запроса для создания пользователя.  
**Вход:** `{ username: 'John', role: 'user' }`  
**Выход:**  
`INSERT INTO users (username, role) VALUES ('John', 'user');`

#### Тест 7. SQL запрос на добавление участника в команду

**Что тестирует:** Проверяется корректность SQL-запроса для добавления участника в команду.  
**Вход:** `teamId='10'`, `userId='user1'`  
**Выход:**  
`INSERT INTO team_members (team_id, user_id) VALUES ('10', 'user1');`

#### Тест 8. Конвертер сущностей во входные бизнес-сущности

**Что тестирует:** Проверка правильности преобразования DTO → BusinessEntity.  
**Вход:** `{ id:'1', title:'Task', points:5 }`  
**Выход:** `{ taskId:'1', name:'Task', score:5 }`

#### Тест 9. Корректность кодов ответа сервиса

**Что тестирует:** Проверяется, что сервис возвращает корректные HTTP-коды.  
**Вход:** запрос на обновление задачи без прав  
**Выход:** `403 Forbidden`

#### Тест 10. Проверка пользователя на участие в группе

**Что тестирует:** Проверяет, входит ли пользователь в состав группы.  
**Вход:** `teamMembers=['user1','user2']`, `userId='user1'`  
**Выход:** `true`

#### Тест 11. Проверка роли участника в команде

**Что тестирует:** Проверяет корректность определения роли участника.  
**Вход:** массив участников, где `user1` имеет роль `manager`  
**Выход:** `'manager'`

### 6.2. Unit-тесты

#### Тест 1. Проверка переходов статусов

**Что тестирует:** Функция canTransitionStatus проверяет, может ли задача перейти из текущего статуса в новый.  
**Вход:** currentStatus='open', newStatus='assigned', isManager=false.  
**Выход:** true (переход разрешен)

#### Тест 2. Фильтрация задач по статусу

**Что тестирует:** Функция filterTasksByStatus фильтрует массив задач по заданному статусу.  
**Вход:** массив из 3 задач (1 open, 1 assigned, 1 completed), фильтр по статусу 'open'.  
**Выход:** массив из 1 задачи с id='1' и status='open'.

#### Тест 3. Подсчет очков

**Что тестирует:** Функция calculateTotalPoints суммирует очки всех задач.  
**Вход:** массив из 3 задач с points: [5, 3, 2].  
**Выход:** 10 (сумма очков).

#### Тест 4. Проверка прав на редактирование

**Что тестирует:** Функция canEditTask проверяет, может ли пользователь редактировать задачу.  
**Вход:** задача с assigneeId='user1', userId='user1', isManager=false.  
**Выход:** true (пользователь может редактировать свою задачу).

#### Тест 5. Группировка задач по исполнителям

**Что тестирует:** Функция groupTasksByAssignee группирует задачи по исполнителям.  
**Вход:** массив из 3 задач (2 назначены на user1, 1 на user2).  
**Выход:** объект { 'user1': [Task, Task], 'user2': [Task] }.

#### Тест 6. Проверка роли менеджера

**Что тестирует:** Функция isUserManager проверяет, является ли пользователь менеджером команды.  
**Вход:** массив участников, userId='user1' (у которого role='manager').  
**Выход:** true (пользователь является менеджером).

#### Тест 7. Форматирование даты

**Что тестирует:** Функция formatDate преобразует ISO дату в формат DD.MM.YYYY.  
**Вход:** '2024-01-15'.  
**Выход:** '15.01.2024'.

#### Тест 8. Валидация названия задачи

**Что тестирует:** Функция isValidTaskTitle проверяет корректность названия задачи (3-100 символов).  
**Вход:** 'Valid Task Name' (15 символов).  
**Выход:** true (название валидно).

#### Тест 9. Подсчет задач по статусам

**Что тестирует:** Функция countTasksByStatus подсчитывает количество задач в каждом статусе.  
**Вход:** массив из 3 задач (по 1 задаче в статусах open, assigned, completed).  
**Выход:** объект { open: 1, assigned: 1, completed: 1 }.

#### Тест 10. Получение имени исполнителя

**Что тестирует:** Функция getAssigneeName возвращает имя исполнителя задачи из списка участников.  
**Вход:** задача с assigneeId='user1', массив участников с username='John Doe'.  
**Выход:** 'John Doe' (имя исполнителя).

#### Тест 11: (`Test_sequentialAction_Perform`) "Успешный сценарий: выполнение всех действий"

**Входные данные:** Список действий `[A1 (ok), A2 (ok)]`.  
**Ожидаемое поведение:** Последовательный вызов всех действий в списке без возврата ошибок.  
**Ожидаемая производительность:** Линейная зависимость O(N).  
**Замечания:** Базовый сценарий успешного выполнения композитного действия.

#### Тест 12: (`Test_sequentialAction_Perform`) "Сценарий сбоя: остановка после первой ошибки"

**Входные данные:** Список действий `[A1 (ok), A2 (error), A3 (ok)]`.  
**Ожидаемое поведение:** Прерывание цепочки вызовов сразу после возникновения ошибки в A2; действие A3 не выполняется.  
**Ожидаемая производительность:** Экономия ресурсов за счет раннего выхода (Fail Fast).  
**Замечания:** Проверка механизма обработки сбоев и остановки конвейера.

#### Тест 13: (`Test_sequentialAction_Perform`) "Пустой список: отсутствие действий"

**Входные данные:** Пустой список `[]`.  
**Ожидаемое поведение:** Мгновенный возврат `nil` (успех), никаких действий не выполняется.  
**Ожидаемая производительность:** Константное время O(1).  
**Замечания:** Тест на устойчивость к некорректной или пустой инициализации.

#### Тест 14: (`Test_allCondition_Holds`) "Все условия истинны: возврат true"

**Входные данные:** Условия `[C1 (true), C2 (true)]`.  
**Ожидаемое поведение:** Вычисление всех условий, возврат `true`, так как оба условия вернули истину.  
**Ожидаемая производительность:** Максимальная сложность O(N).  
**Замечания:** Стандартный сценарий выполнения составного условия.

#### Тест 15: (`Test_allCondition_Holds`) "Одно ложно: возврат false и остановка"

**Входные данные:** Условия `[C1 (true), C2 (false), C3 (true)]`.  
**Ожидаемое поведение:** Прекращение вычислений после первого `false` (C2); условие C3 не проверяется, возвращается
`false`.  
**Ожидаемая производительность:** Оптимизированная (Short-circuit evaluation), время выполнения зависит от индекса
первого отказа.  
**Замечания:** Проверка оптимизации: экономит ресурсы на тяжелых проверках, если легкая проверка уже не прошла.

#### Тест 16: (`Test_allCondition_Holds`) "Проброс ошибки: остановка при сбое"

**Входные данные:** Условия `[C1 (true), C2 (error), C3 (true)]`.  
**Ожидаемое поведение:** Аварийная остановка проверки при получении ошибки от C2, возврат ошибки вместо булевого
результата.  
**Ожидаемая производительность:** Немедленный выход при сбое.  
**Замечания:** Гарантирует, что системные ошибки не будут ошибочно интерпретированы как логическое `false`.

#### Тест 17: (`Test_allCondition_Holds`) "Пустой список: логическая истина"

**Входные данные:** Пустой список `[]`.  
**Ожидаемое поведение:** Возврат `true` без выполнения проверок.  
**Ожидаемая производительность:** Константное время O(1).  
**Замечания:** Соответствует математическому определению "пустой истины" для операции пересечения.

#### Тест 18: (`Test_anyCondition_Holds`) "Одно истинно: возврат true и остановка"

**Входные данные:** Условия `[C1 (false), C2 (true), C3 (false)]`.  
**Ожидаемое поведение:** Прекращение вычислений после первого `true` (C2); условие C3 не проверяется, возвращается
`true`.  
**Ожидаемая производительность:** Оптимизированная (Short-circuit evaluation), вычисления прерываются при первом
успехе.  
**Замечания:** Проверка оптимизации для дизъюнкции.

#### Тест 19: (`Test_anyCondition_Holds`) "Все ложны: возврат false"

**Входные данные:** Условия `[C1 (false), C2 (false)]`.  
**Ожидаемое поведение:** Полный перебор всех условий, так как ни одно не вернуло `true`, итоговый возврат `false`.  
**Ожидаемая производительность:** Максимальная сложность O(N).  
**Замечания:** Сценарий "наихудшего случая" для логического ИЛИ.

#### Тест 20: (`Test_anyCondition_Holds`) "Проброс ошибки: остановка при сбое"

**Входные данные:** Условия `[C1 (false), C2 (error), C3 (true)]`.  
**Ожидаемое поведение:** Аварийная остановка при ошибке в C2, ошибка имеет приоритет над потенциальным успехом C3.  
**Ожидаемая производительность:** Немедленный выход при сбое.  
**Замечания:** Ошибка считается более важным сигналом, чем продолжение поиска истины.

#### Тест 21: (`Test_anyCondition_Holds`) "Пустой список: логическая ложь"

**Входные данные:** Пустой список `[]`.  
**Ожидаемое поведение:** Возврат `false` без выполнения проверок.  
**Ожидаемая производительность:** Константное время O(1).  
**Замечания:** В пустом множестве условий ни одно не может быть истинным (нейтральный элемент для объединения).
